<?xml version="1.0" encoding="utf-8" standalone="yes"?><search><entry><title>Spring源码之路-容器加载相关类简单介绍</title><url>/post/java-spring-source-learning1/</url><categories><category>Java</category><category>Spring源码分析</category></categories><tags><tag>Java</tag><tag>Spring</tag></tags><content type="html"><![CDATA[1.1 容器加载相关类分析 总体类图 BeanDefinitionRegistry AliasRegistry org.springframework.core; &lt;Interface&gt;
管理alias的公共接口，服务于一个另一个超级接口BeanDefinitionRegistry
BeanDefinitionRegistry org.springframework.beans.factory.support;&lt;Interface&gt; extends AliasRegistry
Bean声明注册中心接口，继承了AliasRegistry接口，所以拥有alias管理功能。同时拥有bean定义相关管理的功能；如： BeanDefinition org.springframework.beans.factory.config;&lt;Interface&gt; extends AttributeAccessor, BeanMetadataElement
最小的Bean定义接口，用于记录描述一个bean实例的信息以及进一步实现的信息。
AttributeAccessor org.springframework.core; &lt;Interface&gt;
属性的访问接口，拥有属性的CRUD，以及一个compute。Bean实现它相当于Bean就有了属性的相关功能。
BeanMetadataElement org.springframework.beans;&lt;Interface&gt;
元数据接口，只有getSource一个默认方法。默认实现会返回一个null。 实现这个接口相当于暴露一个方法到外面，告诉人家包装到最底层的object是什么。
SimpleAliasRegistry org.springframework.core;&lt;Class&gt;
这个类是AliasRegistry的简单实现。利用ConcurrentHashMap来存储alias的mapping，key-alias,value-name。斯所以一个name有很多alias。
/** Map from alias to canonical name. */ private final Map&lt;String, String&gt; aliasMap = new ConcurrentHashMap&lt;&gt;(16); checkForAliasCircle(name, alias); 在 registerAlias 中有一个 checkForAliasCircle(name,alias)来防止互为别名。 allowAliasOverriding() 获取是否可以覆盖alias，这里简单设置为ture。提醒，这里alias是有机会拥有自己的alias的。
DefaultSingletonBeanRegistry SingletonBeanRegistry org.springframework.beans.factory.config;&lt;Interface&gt;
管理Singleton的基础接口，暴露singleton CRUD的操作。
DefaultSingletonBeanRegistry org.springframework.beans.factory.support;&lt;Class&gt; extends SimpleAliasRegistry implements SingletonBeanRegistry
主要维护以下几个concurrentHashMap：singletonObjects、singletonFactories、earlySingletonObjects、以及三个set: registeredSingletons、singletonsCurrentlyInCreation、inCreationCheckExclusions 以完成加减SingletonBean的完整的基础流程。其中包含依赖bean的解析过程。 该bean主要是提供一个默认实现。
FactoryBeanRegistrySupport org.springframework.beans.factory.support；abstract &lt;Class&gt; extends DefaultSingletonBeanRegistry
维护factoryBeanObjectCache用于存储factoryBean，它用于支持需要管理FactoryBean的注册中心。同时又拥有DefaultSingletonBeanRegistry的能力。
BeanFactory org.springframework.beans.factory&lt;Interface&gt;
这个是全部Spring容器的根接口，包括之后的configurableBeanFactory和ListableBeanFactory。 这个接口的说明信息上还包含了bean生命周期中14个启动过程和3个消亡过程，一个标准的BeanFactory应该尽可能的覆盖这些过程。 这个接口显然是一个工厂接口，所以基本是获取Bean的实例或属性方法。
常量：FACTORY_BEAN_PREFIX用来标记 是否factoryBean，值为“&amp;”
HierarchicalBeanFactory org.springframework.beans.factory&lt;Interface&gt; extends BeanFactory
就是一个普通的BeanFactory加了等级方法： getParentBeanFactory。用来划分BeanFactory等级的接口。 包含一些关于自动注入的方法，生命周期方法等。&lt;To Be Enrich&gt;
ListableBeanFactory org.springframework.beans.factory&lt;Interface&gt; extends BeanFactory
可以罗列所有bean信息的功能的BeanFactory接口。
StaticListableBeanFactory org.springframework.beans.factory.support;&lt;Class&gt; implements ListableBeanFactory
一个ListableBeanFactory的简单实现。&lt;To Be Enrich&gt;
AutowireCapableBeanFactory org.springframework.beans.factory&lt;Interface&gt; extends BeanFactory
同样继承了BeanFactory，拥有自动注入相关方法的BeanFactory接口。定义了多个常量来，用于描述自动注入的方式。还有一些创建Bean相关的方法。
ConfigurableBeanFactory org.springframework.beans.factory.config; &lt;Interface&gt; extends HierarchicalBeanFactory, SingletonBeanRegistry
这个接口既有单例Bean的注册功能（我告诉你，我是单例Bean）又有层级BeanFactory（可以从中获取Bean，或者从父BeanFactory中获取） 除此之外，它自身还丰富了一些与bean生命周期相关的方法。设置Classloader,设置父BeanFactory，设置BeanPostProcessor等等。
AbstractBeanFactory org.springframework.beans.factory.support &lt;abstract class&gt; extends FactoryBeanRegistrySupport implements ConfigurableBeanFactory 这是BeanFactory的抽象基类，实现了Configurable的所有方法&lt;To Be Enrich&gt;
DefaultListableBeanFactory org.springframework.beans.factory.support &lt;Class&gt; extends AbstractAutowireCapableBeanFactory implements ConfigurableListableBeanFactory, BeanDefinitionRegistry, Serializable
*configurelistablebeanfactory和BeanDefinitionRegistry接口的Spring默认实现: 一个基于bean定义元数据的成熟的bean工厂，可通过后处理器扩展。
典型的用法是在访问bean之前先注册所有bean定义(可能是从bean定义文件中读取)。因此，在本地Bean定义表中，按名称查找Bean是一种成本低廉的操作，操作对象是预先解析的Bean定义元数据对象*。
ConfigurableListableBeanFactory org.springframework.beans.factory.config &lt;Interface&gt; extends ListableBeanFactory, AutowireCapableBeanFactory, ConfigurableBeanFactory
AbstractAutowireCapableBeanFactory org.springframework.beans.factory.support;&lt;abstract class&gt; extends AbstractBeanFactory implements AutowireCapableBeanFactory
提供bean创建(带有构造函数解析)、属性填充、连接(包括自动装配)和初始化。处理运行时bean引用，解析托管集合，调用初始化方法，等等。支持根据名称自动装配构造函数、属性和类型自动装配属性。
]]></content></entry><entry><title>Go Issue During Setting Hugo</title><url>/about/</url><categories><category>Go</category></categories><tags><tag>Go</tag><tag>Hugo</tag><tag>bug</tag></tags><content type="html">ABOUT ME I am Blithe, from Guangzhou,Chia, is a backend developer.</content></entry><entry><title>Spring源码之路-Bean 加载与创建</title><url>/post/java-spring-source-learning3/</url><categories><category>Java</category><category>Spring源码分析</category></categories><tags><tag>Java</tag><tag>Spring</tag></tags><content type="html"><![CDATA[1.3 Bean 加载与创建 getBean getBean是BeanFactory接口中声明的方法，通过Bean名称或者类型，从容器中获取对应的Bean。
AbstractBeanFactory的doGetBean方法分析 在DefaultSingletonBeanRegistry几种集合 singletonObjects,Map&lt;String,Object&gt;,bean名称与单例对象的ConcurrentHashMap(256) singletonsCurrentlyInCreation，Set，记录着正在创建中的BeanName earlySingletonObjects，Map&lt;String,Object&gt;，bean名称与早期单例对象的ConcurrentHashMap(16) 1级缓存 singletonFactories,Map&lt;String,ObjectFactory<?>&gt;，Bean名称和对应工厂的HashMap(16) 用来生成Bean singletonFactories,Map&lt;String,ObjectFactory<?>&gt;，Bean名称和对应工厂的HashMap(16) 用来生成Bean factoryBeanObjectCache，Map&lt;String,Object&gt;，FactoryBeanRegistrySupport下记录由工厂生成的单例bean。这些是由FactoryBean生成的Bean缓存。 factoryBeanInstanceCache, ConcurrentMap&lt;String, BeanWrapper&gt;，记录未完整的Bean，以BeanWrapper封装着。 Bean的加载，doGetBean 获取Bean实例 直接从singletonObject中获取单例对象，根据一些条件判断单例中的bean（从缓存中获取Bean实例） 其中先从singletonObjects获取，再到earlySingletonObjects中。若都没有就会从singletonFactories中获取ObjectFactory。某些对象初始化就会调用addSingletonFactory来将singletonFactory加到singletonFactories缓存中。如果最终走到singletonFacotry来获取Bean的话，会调用它的getObject方法，然后put到earlySingletonObjects，同时又从singletonFactories拿走。 如果第一次获取不到对象就往 上请求，getParentBeanFactory，让ParentBean帮忙获取。 利用RootBeanDefinition来注册一些依赖的Bean。同时也利用Scope来做判断加载Bean是否正确。利用dependentBeanMap，dependenciesForBeanMap来维护依赖bean与它依赖的map、以及bean与依赖它的map。 从Bean实例中获取Object 无论最后是从哪里获取的BeanInstance，都逃不过一个统一高频的处理方法getObjectForBeanInstance来获取真正的Bean。其实就是为了处理FactoryBean的情况（通常Beanname以&amp;开头）。首先，看看factoryBeanObjectCache是否由缓存相应Factory生成的Bean，如果没有就从这个FactoryBean调用getObect来获取。
后置处理postProcess getObjectFromFactoryBean中除了会获取到Object实例以外，还会对Object进行后置操作。对应衍生出三个步骤
beforeSingletonCreation：检查inCreationCheckExclusions不包含，且singletonsCurrentlyInCreation没有同名的bean正在创建中。有则会抛出BeanCurrentlyInCreationException。 postProcessObjectFromFactoryBean: AbstractAutowireCapableBeanFactory中的实现，通过getBeanPostProcessors()获取所有的postProcessor，然后遍历调用他们的postProcessAfterInitialization，遍历完之后返回，遍历期间方法一旦返回null就会直接返回。 afterSingletonCreation:检查inCreationCheckExclusions不包含,singletonsCurrentlyInCreation能remove，不能就会抛出IllegalStateException。 Create Bean doGetBean前 根据className获取对应的Class，如果能获取到对应class名则将会copy一个新的RootBeanDefinition使用 Override 属性标记验证（prepareMethodOverride） 获取所有override的方法，判断每个方法对应在自己类，接口，父类上同一个方法名的数量，小于1就是有问题的，要抛异常。=1怎么只有一个方法，所以这里肯定不是重载，从代码里直接标记了不是overload,方便了后续需要根据参数来定义方法调用事，直接查看这个标记，如果为false就直接调用得了。 resolveBeforeInstantiation 解决初始化之前相关的事，BeanPostProcessor applyBeanPostProcessorsBeforeInstantiation，先执行。有机会产生一个代理对象，如果对应的class是有AOP增强的话。 applyBeanPostProcessorsAfterInitialization，bean的后置操作，既然上一步都生成一个Bean实例了，就要按照正常流程把BeanProcessor要做的事也做完。 如果在这步就获得对象就会直接返回，因为对于做了AOP增强的Bean来说，Bean实例应该是一个代理对象。
doGetBean 执行doCreateBean的方法，来到这一步证明这个只是一个普通的Bean了。 创建Bean实例的方法createInstance，执行后得到的是BeanWrapper。在这个方法中，会推断使用什么方式来实例化这个Bean。最后从中获取对应的Bean和Class。 上一步证明了它已经完成Bean的create，执行mergedDefinition的PostProcessor 解决循环依赖的问题，这里有一个变量：earlySingletonExpose = 是单例+允许循环依赖+当前Bean正在生成。 会将此时的Bean加入SingletonFacotries和registerSingletonObject中，从earlySingleton中remove。其中加入SingletonFacotries的getObjct方法是一个lamda表达式，他会检测是否实现AOP，若有则返回proxy对象 populateBean，initializeBean（before，invoke，after） earlySingletonExposure 一些checking。throw BeanCurrentlyInCreationException exception Register Bean as Disposable 注意 由于单例就会缓存在，SingletonFactories和registerSingletonObject中，所以只有Bean的作用域是Singleton时才会支持循环依赖。对于prototype作用域的bean来说，Spring是无法完成注入的。 对于singleton作用域的bean，可以设置setAllowCircularReference（false）来禁止使用循环依赖。 ]]></content></entry><entry><title>Spring源码之路-Reader相关类分析</title><url>/post/java-spring-source-learning2/</url><categories><category>Java</category><category>Spring源码分析</category></categories><tags><tag>Java</tag><tag>Spring</tag></tags><content type="html"><![CDATA[1.2 Reader相关类分析 BeanDefinitionReader org.springframework.beans.factory.support interface
提供了一些加载BeanDefinition的方法提供实现。这个接口更多的是建议读者按照这个标准去定义一个reader，没有强制一定要实现它的方法。 提供从Resource或者特定Resource路径下来加载Bean Definition。
AbstractBeanDefinitionReader org.springframework.beans.factory.support abstract class
实现了大部分方法，但留有比较核心，需要定制的方法暴露给继承他的子类来实现。如 loadBeanDefinitions(Resource resource) 实现类有：XmlBeanDefinitionReader GroovyBeanDefinitionReader
XmlBeanDefinitionReader org.springframework.beans.factory.xml class extends AbstractBeanDefinitionReader
为使用XML描述Bean读取提供的Reader。
GroovyBeanDefinitionReader org.springframework.beans.factory.groovy class extends AbstractBeanDefinitionReader implements GroovyObject
A Groovy-based reader for Spring bean definitions: like a Groovy builder, but more of a DSL for Spring configuration.
从Unit Test分析Spring使用XML注入Bean的过程 以下这段代码位于org.springframework.core.env.EnvironmentSystemIntegrationTests这个测试类之下。大致的内容是，加载XML_PATH这个xml,然后判断是否正确加载。
以这个类为基础研究以下XmlBeanDefinitionReader加载Bean的过程。
org.springframework.core.env.EnvironmentSystemIntegrationTests
@Test void xmlBeanDefinitionReader_inheritsEnvironmentFromEnvironmentCapableBDR() { GenericApplicationContext ctx = new GenericApplicationContext(); ctx.setEnvironment(prodEnv); new XmlBeanDefinitionReader(ctx).loadBeanDefinitions(XML_PATH); ctx.refresh(); assertThat(ctx.containsBean(DEV_BEAN_NAME)).isFalse(); assertThat(ctx.containsBean(PROD_BEAN_NAME)).isTrue(); } 重点方法是 new XmlBeanDefinitionReader(ctx).loadBeanDefinitions(XML_PATH);背后调用的是AbstractBeanDefinitionReader.java中的loadBeanDefinitions方法。最后，调用到
loadBeanDefinitions 使用ThreadLocal一个HashSet变量resourcesCurrentlyBeingLoaded来判断是否正在加载。 利用入参封装一个InputSource。 然后调用 doLoadBeanDefinitions(InputSource, Resource) doLoadBeanDefinitions(InputSource, Resource) 会调用 doLoadDocument(inputSource, resource) 获取一个Document对象。这个类可以理解为XML的一个document形式的封装，相当于HTML的&lt;root&gt;标签入口，它让你能够层级去访问XML的内容。 doLoadDocument(inputSource, resource) 先getValidationMode DocumentLoader.loadDocument(InputSource, EntityResolver,ErrorHandler, int validationMode, boolean namespaceAware) 最终是通过根据入参，validationMode、 namespaceAware、 创建DocumentBuilderFactory结合entityResolver、errorHandler来创建DocumentBuilder对象来解析InputSource获得Document对象。 拿到Document对象之后registerBeanDefinitions(Document, Resource),创建一个DocReader去注册BeanDefinitions。 最终调用一个doRegisterBeanDefinitions(Element root)来注册Bean。 preProcessXml(root); AOP相关 parseBeanDefinitions(root, this.delegate); 真正一层一层找Bean，DefaultBeanDefinitionDocumentReader.parseDefaultElement(Element, BeanDefinitionParserDelegate)是真正分发去看不同类型的声明。查看它究竟是import，alias，bean还是beans节点。这里很巧妙地用来递归实现。 private void parseDefaultElement(Element ele, BeanDefinitionParserDelegate delegate) { if (delegate.nodeNameEquals(ele, IMPORT_ELEMENT)) { importBeanDefinitionResource(ele); //loadBeanDefinitions(String location, @Nullable Set&lt;Resource&gt; actualResources) } else if (delegate.nodeNameEquals(ele, ALIAS_ELEMENT)) { processAliasRegistration(ele); //getReaderContext().getRegistry().registerAlias(name, alias); } else if (delegate.nodeNameEquals(ele, BEAN_ELEMENT)) { processBeanDefinition(ele, delegate); //最终会调用到registerBeanDefinition(String beanName, BeanDefinition beanDefinition) } else if (delegate.nodeNameEquals(ele, NESTED_BEANS_ELEMENT)) { // recurse doRegisterBeanDefinitions(ele); //doRegisterBeanDefinitions(ele);递归调用回去 } } 4.postProcessXml(root); **AOP相关** ]]></content></entry><entry><title>Go Issue During Setting Hugo</title><url>/post/go-issue-during-setting-hugo/</url><categories><category>Go</category></categories><tags><tag>Go</tag><tag>Hugo</tag><tag>bug</tag></tags><content type="html">Connection fail 由于代理网站为国外网站，所以需要用以下命令来更改代理网站
go env -w GOPROXY=https://goproxy.cn,direct
Go install 无反应，安装的程序不能执行 由于go path未未设置在系统环境变量中，导致即便安装了程序在go_path里，执行时却无法发现。
go env #获取GOPATH路径，将其设置为系统变量</content></entry><entry><title>Java Spring Source Learning3</title><url>/java-spring-source-learning3/</url><categories/><tags/><content type="html"></content></entry></search>